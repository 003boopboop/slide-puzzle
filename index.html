<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slide Puzzle</title>
  <style>
    :root{
      --n: 4;                 /* grid size (4 = 4x4) */
      --gap: 10px;
      --bg: #0b0d10;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.10);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.68);
      --shadow: 0 18px 60px rgba(0,0,0,0.55);
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 50% 10%, #1a2333 0%, var(--bg) 60%, #050608 100%);
      color: var(--text);
      min-height: 100svh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 22px;
    }

    .wrap{
      width: min(920px, 96vw);
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      padding: 14px 16px;
      background: linear-gradient(180deg, var(--panel), transparent);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .title{
      display:flex;
      flex-direction:column;
      gap: 4px;
    }
    .title h1{
      font-size: 18px;
      margin:0;
      letter-spacing: 0.2px;
    }
    .title p{
      margin:0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      justify-content:flex-end;
      align-items:center;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, var(--panel2), rgba(255,255,255,0.04));
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 600;
      font-size: 13px;
      letter-spacing: 0.2px;
      transition: transform .08s ease, border-color .15s ease, background .15s ease;
      user-select:none;
    }
    button:hover{ border-color: rgba(255,255,255,0.28); }
    button:active{ transform: translateY(1px) scale(0.99); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .stats{
      display:flex;
      gap: 10px;
      align-items:center;
      color: var(--muted);
      font-size: 13px;
      padding-right: 2px;
      user-select:none;
    }
    .pill{
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
    }

    /* Board */
    .boardShell{
      position: relative;
      border-radius: calc(var(--radius) + 8px);
      padding: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.15));
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .board{
      width: min(86vmin, 760px);
      aspect-ratio: 1 / 1; /* your image is square; keeps it neat */
      margin: 0 auto;
      display:grid;
      grid-template-columns: repeat(var(--n), 1fr);
      grid-template-rows: repeat(var(--n), 1fr);
      gap: var(--gap);
      position: relative;
      touch-action: manipulation;
      user-select:none;
    }

    .tile{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background-color: #0a0c10;
      background-image: var(--img);
      background-repeat:no-repeat;
      background-size: calc(var(--n) * 100%) calc(var(--n) * 100%);
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      cursor:pointer;
      transition: transform .08s ease, filter .2s ease, box-shadow .2s ease;
    }
    .tile:hover{
      filter: brightness(1.06);
      box-shadow: 0 14px 40px rgba(0,0,0,0.44);
    }
    .tile:active{ transform: scale(0.995); }
    .tile.empty{
      background-image: none !important;
      border: 1px dashed rgba(255,255,255,0.18);
      box-shadow: none;
      cursor: default;
      filter: none;
      background: rgba(0,0,0,0.30);
    }

    /* Win overlay that reveals full image */
    .reveal{
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      opacity:0;
      transition: opacity .35s ease;
    }
    .reveal.show{ opacity:1; }

    .revealCard{
      width: min(86vmin, 760px);
      aspect-ratio: 1 / 1;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 26px 90px rgba(0,0,0,0.60);
      overflow:hidden;
      position:relative;
      transform: translateY(8px) scale(0.995);
      animation: popIn .38s ease forwards;
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(6px);
    }
    .revealImg{
      position:absolute;
      inset:0;
      background-image: var(--img);
      background-size: cover;
      background-position:center;
      filter: saturate(1.04) contrast(1.02);
    }

    .winBanner{
      position:absolute;
      left: 18px;
      right: 18px;
      bottom: 18px;
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(0,0,0,0.44);
      border: 1px solid rgba(255,255,255,0.18);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
    }
    .winBanner strong{ font-size: 14px; }
    .winBanner span{ color: var(--muted); font-size: 13px; }

    @keyframes popIn{
      to { transform: translateY(0) scale(1); }
    }

    /* Flutter / shimmer effect */
    .flutter{
      position:absolute;
      inset:-20%;
      background:
        radial-gradient(closest-side, rgba(255,255,255,0.22), transparent 70%) 20% 30% / 120px 120px no-repeat,
        radial-gradient(closest-side, rgba(255,255,255,0.18), transparent 70%) 72% 24% / 160px 160px no-repeat,
        radial-gradient(closest-side, rgba(255,255,255,0.14), transparent 70%) 38% 75% / 180px 180px no-repeat,
        linear-gradient(120deg, transparent 35%, rgba(255,255,255,0.18) 48%, transparent 61%);
      mix-blend-mode: screen;
      opacity: 0;
      transform: rotate(6deg);
      animation: flutterSweep 1.25s ease-in-out forwards;
      pointer-events:none;
    }
    @keyframes flutterSweep{
      0%   { opacity:0; transform: translateX(-12%) rotate(6deg); }
      18%  { opacity:0.70; }
      55%  { opacity:0.35; }
      100% { opacity:0; transform: translateX(12%) rotate(6deg); }
    }

    /* Sparkles */
    .sparkles{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:hidden;
    }
    .sparkle{
      position:absolute;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.9);
      filter: blur(0.2px);
      opacity: 0;
      animation: sparkle 900ms ease-out forwards;
    }
    @keyframes sparkle{
      0%   { transform: translateY(10px) scale(0.6); opacity:0; }
      20%  { opacity:0.95; }
      100% { transform: translateY(-28px) scale(0.15); opacity:0; }
    }

    footer{
      text-align:center;
      color: var(--muted);
      font-size: 12px;
      opacity: .95;
      padding: 2px 8px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Slide Puzzle</h1>
        <p>Click/tap a tile next to the empty space to slide it. When solved, the missing piece appears and the full image is revealed.</p>
      </div>
      <div class="controls">
        <div class="stats">
          <div class="pill">Moves: <span id="moves">0</span></div>
          <div class="pill">Time: <span id="time">0:00</span></div>
        </div>
        <button id="shuffleBtn">Shuffle</button>
        <button id="resetBtn">Reset</button>
      </div>
    </header>

    <div class="boardShell">
      <div id="board" class="board" aria-label="Sliding puzzle board"></div>

      <!-- Reveal overlay -->
      <div id="reveal" class="reveal" aria-hidden="true">
        <div class="revealCard" id="revealCard">
          <div class="revealImg"></div>
          <div class="flutter"></div>
          <div class="sparkles" id="sparkles"></div>
          <div class="winBanner">
            <div>
              <strong>✅ Puzzle solved!</strong>
              <div><span id="winStats">Nice work.</span></div>
            </div>
            <span>(Full image revealed)</span>
          </div>
        </div>
      </div>
    </div>

    <footer>
      Tip: You can host this on GitHub Pages / Netlify / Vercel as a static site.
    </footer>
  </div>

<script>
(() => {
  // ✅ Change this if your image filename differs
  const IMG_SRC = "puzzle.png";

  // Grid size (4x4)
  const N = 4;

  // Shuffle strength: number of random legal moves from solved
  const SHUFFLE_MOVES = 250;

  const boardEl = document.getElementById("board");
  const movesEl = document.getElementById("moves");
  const timeEl = document.getElementById("time");
  const shuffleBtn = document.getElementById("shuffleBtn");
  const resetBtn = document.getElementById("resetBtn");

  const revealEl = document.getElementById("reveal");
  const winStatsEl = document.getElementById("winStats");
  const sparklesEl = document.getElementById("sparkles");

  // State: array of length N*N, containing tile ids 0..N*N-2, and -1 for empty
  // Tile id corresponds to its solved position in row-major order.
  let state = [];
  let tiles = []; // tile DOM elements by tile id
  let emptyIndex = N*N - 1;

  let moves = 0;
  let timer = null;
  let startTime = null;
  let finished = false;

  // Apply CSS vars
  document.documentElement.style.setProperty("--n", String(N));
  boardEl.style.setProperty("--n", String(N));
  boardEl.style.setProperty("--img", `url("${IMG_SRC}")`);

  // Preload image for reveal background as well
  document.querySelectorAll(".revealImg").forEach(el => {
    el.style.setProperty("--img", `url("${IMG_SRC}")`);
    el.style.backgroundImage = `url("${IMG_SRC}")`;
  });
  document.getElementById("revealCard").style.setProperty("--img", `url("${IMG_SRC}")`);

  function formatTime(ms){
    const s = Math.floor(ms/1000);
    const m = Math.floor(s/60);
    const r = s % 60;
    return `${m}:${String(r).padStart(2,"0")}`;
  }

  function setTimeNow(){
    if (!startTime) return;
    timeEl.textContent = formatTime(Date.now() - startTime);
  }

  function startTimer(){
    if (timer) clearInterval(timer);
    startTime = Date.now();
    timeEl.textContent = "0:00";
    timer = setInterval(setTimeNow, 250);
  }

  function stopTimer(){
    if (timer) clearInterval(timer);
    timer = null;
  }

  function buildSolvedState(){
    state = Array.from({length: N*N}, (_, i) => (i === N*N-1 ? -1 : i));
    emptyIndex = N*N - 1;
  }

  function posFromIndex(idx){
    return { r: Math.floor(idx / N), c: idx % N };
  }

  function indexFromPos(r,c){
    return r*N + c;
  }

  function neighbors(idx){
    const {r,c} = posFromIndex(idx);
    const out = [];
    if (r>0) out.push(indexFromPos(r-1,c));
    if (r<N-1) out.push(indexFromPos(r+1,c));
    if (c>0) out.push(indexFromPos(r,c-1));
    if (c<N-1) out.push(indexFromPos(r,c+1));
    return out;
  }

  function canMove(tileIndex){
    return neighbors(tileIndex).includes(emptyIndex);
  }

  function swap(i,j){
    const tmp = state[i];
    state[i] = state[j];
    state[j] = tmp;
  }

  function render(){
    // Clear and rebuild the board each render for simplicity + correctness
    boardEl.innerHTML = "";
    boardEl.style.setProperty("--img", `url("${IMG_SRC}")`);

    for (let i=0; i<state.length; i++){
      const tileId = state[i];
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.setAttribute("role","button");

      if (tileId === -1){
        tile.classList.add("empty");
        tile.setAttribute("aria-label","Empty space");
      } else {
        // Background position based on tileId's solved row/col
        const sr = Math.floor(tileId / N);
        const sc = tileId % N;
        const x = (sc * 100) / (N - 1);
        const y = (sr * 100) / (N - 1);
        tile.style.backgroundImage = `url("${IMG_SRC}")`;
        tile.style.backgroundPosition = `${x}% ${y}%`;
        tile.setAttribute("aria-label", `Tile ${tileId+1}`);

        tile.addEventListener("click", () => {
          if (finished) return;
          if (!canMove(i)) return;
          if (moves === 0 && !timer) startTimer();
          makeMove(i);
        });
      }

      boardEl.appendChild(tile);
    }
  }

  function isSolved(){
    // solved if state[i] = i for all except last is -1
    for (let i=0; i<N*N-1; i++){
      if (state[i] !== i) return false;
    }
    return state[N*N-1] === -1;
  }

  function makeMove(tileIndex){
    if (!canMove(tileIndex)) return;
    swap(tileIndex, emptyIndex);
    emptyIndex = tileIndex;

    moves += 1;
    movesEl.textContent = String(moves);

    render();

    if (isSolved()){
      win();
    }
  }

  function shuffle(){
    finished = false;
    revealEl.classList.remove("show");
    revealEl.setAttribute("aria-hidden","true");
    sparklesEl.innerHTML = "";

    buildSolvedState();
    moves = 0;
    movesEl.textContent = "0";
    stopTimer();
    startTime = null;
    timeEl.textContent = "0:00";

    // Perform random legal moves from solved state => always solvable
    let lastEmpty = emptyIndex;
    for (let k=0; k<SHUFFLE_MOVES; k++){
      const neigh = neighbors(emptyIndex);
      // Avoid immediately undoing the previous move where possible
      const choices = neigh.filter(n => n !== lastEmpty);
      const pickFrom = choices.length ? choices : neigh;
      const pick = pickFrom[Math.floor(Math.random() * pickFrom.length)];
      lastEmpty = emptyIndex;
      swap(pick, emptyIndex);
      emptyIndex = pick;
    }

    render();
  }

  function reset(){
    finished = false;
    revealEl.classList.remove("show");
    revealEl.setAttribute("aria-hidden","true");
    sparklesEl.innerHTML = "";

    buildSolvedState();
    moves = 0;
    movesEl.textContent = "0";
    stopTimer();
    startTime = null;
    timeEl.textContent = "0:00";
    render();
  }

  function addSparkles(){
    sparklesEl.innerHTML = "";
    const count = 34;
    for (let i=0; i<count; i++){
      const s = document.createElement("div");
      s.className = "sparkle";
      const left = Math.random()*100;
      const top = 60 + Math.random()*35; // near bottom for a "burst up"
      s.style.left = left + "%";
      s.style.top = top + "%";
      s.style.animationDelay = (Math.random()*180) + "ms";
      s.style.transform = `translateY(10px) scale(${0.5 + Math.random()*0.7})`;
      sparklesEl.appendChild(s);
    }
    // Clear after animation completes
    setTimeout(() => { sparklesEl.innerHTML = ""; }, 1200);
  }

  function win(){
    finished = true;
    stopTimer();

    const totalTime = startTime ? (Date.now() - startTime) : 0;
    winStatsEl.textContent = `Moves: ${moves} • Time: ${formatTime(totalTime)}`;

    // ✅ Show the missing tile too (so the completed image is visible)
    // We do this by rendering a "solved" visual state behind the reveal overlay.
    // (The overlay itself is the full image.)
    revealEl.classList.add("show");
    revealEl.setAttribute("aria-hidden","false");
    addSparkles();

    // Optional: lock buttons briefly? (Not necessary, but can feel nice)
  }

  // Buttons
  shuffleBtn.addEventListener("click", shuffle);
  resetBtn.addEventListener("click", reset);

  // Keyboard support (arrow keys move the empty space by sliding a neighbor tile)
  window.addEventListener("keydown", (e) => {
    if (finished) return;

    const {r,c} = posFromIndex(emptyIndex);
    let target = null;

    if (e.key === "ArrowUp")    { if (r < N-1) target = indexFromPos(r+1,c); } // tile below moves up
    if (e.key === "ArrowDown")  { if (r > 0)   target = indexFromPos(r-1,c); }
    if (e.key === "ArrowLeft")  { if (c < N-1) target = indexFromPos(r,c+1); }
    if (e.key === "ArrowRight") { if (c > 0)   target = indexFromPos(r,c-1); }

    if (target !== null){
      e.preventDefault();
      if (moves === 0 && !timer) startTimer();
      makeMove(target);
    }
  }, {passive:false});

  // Init
  reset();
})();
</script>
</body>
</html>
